import * as vscode from "vscode";
import { GeneratedFileDecorationProvider } from "./generated_file_decorator";

async function readTextFromFile(uri: vscode.Uri) {
  const readData = await vscode.workspace.fs.readFile(uri);
  return Buffer.from(readData).toString("utf8");
}

export class ProjenInfo {
  public managedFiles: string[] = [];
  public tasks: ProjenTask[] = [];
  public dependencies: ProjenDependency[] = [];
  decorator: GeneratedFileDecorationProvider;

  constructor(public workspaceRoot: vscode.Uri) {
    this.decorator = new GeneratedFileDecorationProvider();
    vscode.window.registerFileDecorationProvider(this.decorator);
  }

  async update() {
    const projenFolderFiles = await vscode.workspace.findFiles(
      new vscode.RelativePattern(this.workspaceRoot, ".projen/*")
    );
    const rootFiles = await vscode.workspace.findFiles(
      new vscode.RelativePattern(this.workspaceRoot, "*")
    );

    if (projenFolderFiles.length == 0) {
      void vscode.commands.executeCommand(
        "setContext",
        "projen.inProject",
        false
      );

      this.managedFiles = [];
      this.dependencies = [];
      this.decorator.files = [];

      return;
    }

    let files: vscode.Uri[] = [];
    let verifiedFiles = false;

    const fileManifestUri = projenFolderFiles.find((f) =>
      f.fsPath.endsWith("files.json")
    );
    if (fileManifestUri) {
      try {
        const fileManifest = await readTextFromFile(fileManifestUri);
        const fileData: string[] = JSON.parse(fileManifest).files;
        files = fileData.map((f) => vscode.Uri.joinPath(this.workspaceRoot, f));

        // handles special cases
        const specialFiles = rootFiles.filter(
          (f) =>
            f.fsPath.endsWith("package-lock.json") ||
            f.fsPath.endsWith(".lock") ||
            f.fsPath.endsWith("package.json")
        );
        if (specialFiles.length > 0) {
          files.push(...specialFiles);
        }

        verifiedFiles = true;
      } catch (error) {
        console.error(error);
      }
    }

    if (files.length === 0) {
      files.push(...rootFiles, ...projenFolderFiles);
    }

    void vscode.commands.executeCommand("setContext", "projen.inProject", true);

    const projenManaged: vscode.Uri[] = [];
    for (const f of files) {
      if (
        verifiedFiles ||
        f.fsPath.endsWith("package-lock.json") ||
        f.fsPath.endsWith(".lock")
      ) {
        // TODO handle lockfiles in a smarter way
        // Since dependencies are managed by projen, a lockfile is as well (kinda)
        // lock files are typically huge, would much rather not try to search them
        projenManaged.push(f);
      } else {
        const fileContent = await readTextFromFile(f);
        if (
          fileContent.includes(
            `~~` + ` Generated by projen. To modify, edit .projenrc`
          )
        ) {
          projenManaged.push(f);
        }
      }
    }

    for (const f of projenManaged) {
      if (f.fsPath.endsWith("tasks.json")) {
        const fileContent = await readTextFromFile(f);
        const taskData = JSON.parse(fileContent).tasks;

        this.tasks = Object.values(taskData).map((t: any) => new ProjenTask(t));
        this.tasks.sort((a, b) => a.name.localeCompare(b.name));
      } else if (f.fsPath.endsWith("deps.json")) {
        const fileContent = await readTextFromFile(f);
        const depData = JSON.parse(fileContent).dependencies;
        depData.sort((a: any, b: any) => a.name.localeCompare(b.name));

        this.dependencies = depData.map(
          (d: any) => new ProjenDependency(d.name, d.type, d.version)
        );
      }
    }

    const directoryMap: any = {};
    projenManaged.forEach((f) => {
      const directory = f.fsPath
        .replace(/\\/g, "/")
        .split("/")
        .slice(0, -1)
        .join("/");
      if (directoryMap[directory] !== undefined) {
        directoryMap[directory]++;
      } else {
        directoryMap[directory] = 1;
      }
    });

    let managedDirectories: string[] = [];
    for (const d of Object.keys(directoryMap)) {
      const filesFromDir = await vscode.workspace.findFiles(
        new vscode.RelativePattern(d, "*")
      );

      if (directoryMap[d] === filesFromDir.length) {
        managedDirectories.push(d);
      }
    }

    if (managedDirectories.length > 0) {
      projenManaged.push(...managedDirectories.map((d) => vscode.Uri.file(d)));
    }

    this.decorator.files = projenManaged.map((f) => f.fsPath);

    this.managedFiles = projenManaged.map((file: vscode.Uri) => {
      const removedRoot = file.fsPath.replace(this.workspaceRoot.fsPath, "");
      const betterFile = removedRoot.replace(/\\/g, "/");

      if (betterFile.startsWith("/")) {
        return betterFile.slice(1);
      } else {
        return betterFile;
      }
    });

    this.managedFiles.sort();

    this.decorator._onDidChangeFileDecorations.fire(projenManaged);
  }
}
export class ProjenStep {
  constructor(public type: string, public value: string) {}
}

export class ProjenTask {
  public name: string;
  public description?: string;
  public steps: ProjenStep[];

  constructor(taskData: any) {
    this.name = taskData.name;
    this.description = taskData.description;
    this.steps = (taskData.steps ?? []).map((s: any) => {
      const entries = Object.entries(s)[0];
      return new ProjenStep(entries[0], entries[1] as any);
    });
  }
}

export class ProjenDependency {
  constructor(
    public name: string,
    public type: string,
    public version?: string
  ) {}
}
