import * as fs from "fs";
import * as vscode from "vscode";

class GeneratedFileDecorationProvider implements vscode.FileDecorationProvider {
  private static Decoration: vscode.FileDecoration = {
    color: new vscode.ThemeColor("gitDecoration.ignoredResourceForeground"),
    badge: "PJ",
    tooltip: "Managed By Projen. Edit the projenrc file to make changes.",
  };

  public files: string[];

  public _onDidChangeFileDecorations: vscode.EventEmitter<vscode.Uri[]> =
    new vscode.EventEmitter<vscode.Uri[]>();
  readonly onDidChangeFileDecorations: vscode.Event<vscode.Uri[]> =
    this._onDidChangeFileDecorations.event;

  constructor() {
    this.files = [];
  }

  provideFileDecoration(
    uri: vscode.Uri,
    _token: vscode.CancellationToken
  ): vscode.ProviderResult<vscode.FileDecoration> {
    if (this.files.length == 0) {
      return null;
    }

    if (this.files.includes(uri.fsPath)) {
      return GeneratedFileDecorationProvider.Decoration;
    } else {
      return null;
    }
  }
}

type TreeType = void | File | null | undefined;

export class ProjenFileView implements vscode.TreeDataProvider<File> {
  public _onDidChangeTreeData: vscode.EventEmitter<TreeType> =
    new vscode.EventEmitter<TreeType>();
  readonly onDidChangeTreeData: vscode.Event<TreeType> =
    this._onDidChangeTreeData.event;

  decorator: GeneratedFileDecorationProvider;

  constructor(private workspaceRoot: string) {
    this.decorator = new GeneratedFileDecorationProvider();
    vscode.window.registerFileDecorationProvider(this.decorator);
  }

  getTreeItem(element: File): vscode.TreeItem {
    return element;
  }

  async getChildren(element?: File): Promise<File[]> {
    if (!this.workspaceRoot) {
      void vscode.window.showInformationMessage("No files in empty workspace");
      return Promise.resolve([]);
    }

    if (!element) {
      const files = await vscode.workspace.findFiles("*");
      const projenManaged: vscode.Uri[] = [];
      files.forEach((f) => {
        if (f.fsPath.includes("package-lock.json")) {
          // TODO handles all lock files
          // lock files are huge, would much rather not try to parse them
          projenManaged.push(f);
        } else {
          const fileContent = fs.readFileSync(f.fsPath, "utf-8");
          if (
            fileContent.includes(
              `~~` + ` Generated by projen. To modify, edit .projenrc`
            )
          ) {
            projenManaged.push(f);
          }
        }
      });

      this.decorator.files = projenManaged.map((f) => f.fsPath);
      this.decorator.files.push("");
      this.decorator._onDidChangeFileDecorations.fire(projenManaged);

      return Promise.resolve(
        projenManaged.map((file: vscode.Uri) => {
          const removedRoot = file.fsPath.replace(this.workspaceRoot, "");
          const betterFile = removedRoot.replace(/\\/g, "/");

          if (betterFile.startsWith("/")) {
            return new File(betterFile.slice(1));
          } else {
            return new File(betterFile);
          }
        })
      );
    }

    this.decorator._onDidChangeFileDecorations.fire([]);
    return Promise.resolve([]);
  }
}

class File extends vscode.TreeItem {
  iconPath = new vscode.ThemeIcon("file");
  constructor(public readonly file: any) {
    super(file, vscode.TreeItemCollapsibleState.None);

    this.tooltip = "";
  }
}
